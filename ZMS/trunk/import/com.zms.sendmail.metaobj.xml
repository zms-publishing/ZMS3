<?xml version="1.0" encoding="UTF-8"?>
<dictionary>
    <item key="key"><![CDATA[com.zms.sendmail]]></item>
    <item key="value" type="dictionary">
      <dictionary>
        <item key="__obj_attrs__" type="list">
          <list>
            <item type="dictionary">
              <dictionary>
                <item key="custom"><![CDATA[# ------------------------------------------------------------------------------
# Changes:
# 2008-10-10 [st]: Added support for smtp-authentication.
# ------------------------------------------------------------------------------

import smtplib
import os
from email.MIMEMultipart import MIMEMultipart
from email.MIMEImage import MIMEImage
from email.MIMEBase import MIMEBase
from email.MIMEText import MIMEText
from email.Utils import COMMASPACE, formatdate
from email import Encoders

def send_mail(send_from, send_to, subject, text, files=[], server="localhost", send_cc=[], smtp_user=None, smtp_passwd=None):
  assert type(send_to)==list
  assert type(send_cc)==list
  assert type(files)==list
  
  rtn = ''
  rtn += '\n[send_mail] from: '+str(send_from)
  rtn += '\n[send_mail] to: '+str(send_to)
 
  msgRoot = MIMEMultipart('related')
  msgRoot['From'] = send_from
  msgRoot['To'] = COMMASPACE.join(send_to)
  if send_cc: msgRoot['Cc'] = COMMASPACE.join(send_cc)
  msgRoot['Date'] = formatdate(localtime=True)
  msgRoot['Subject'] = subject
  msgRoot.preamble = 'This is a multi-part message in MIME format.'

  # Encapsulate the plain and HTML versions of the message body in an
  # 'alternative' part, so message agents can decide which they want to display.
  msgAlternative = MIMEMultipart('alternative')
  msgRoot.attach(msgAlternative)

  msgText = MIMEText(text, _subtype='html', _charset='utf-8')
  msgAlternative.attach(msgText)

  for f in files:
    assert type(f)==dict
    rtn += '\n[send_mail] MimeBase'
    part = MIMEBase('application', "octet-stream")
    part.set_payload( f['data'] )
    Encoders.encode_base64(part)
    part.add_header('Content-Disposition', 'attachment; filename="%s"' % os.path.basename(f['filename']))
    if f.get('cid'):
      part.add_header('Content-Id', f['cid'] )
      rtn += '\n[send_mail] Content-Id: '+f['cid']
    msgRoot.attach(part)
 
  # Send the email
  smtp = smtplib.SMTP(server)
  if smtp_user is not None:
    smtp.login(smtp_user,smtp_passwd)
  smtp.sendmail(send_from, send_to + send_cc, msgRoot.as_string())
  
  smtp.close()
  
  return rtn]]>
                </item>
                <item key="id"><![CDATA[send_mail]]></item>
                <item key="mandatory" type="int">0</item>
                <item key="multilang" type="int">0</item>
                <item key="name"><![CDATA[send_mail]]></item>
                <item key="repetitive" type="int">0</item>
                <item key="type"><![CDATA[External Method]]></item>
              </dictionary>
            </item>
          </list>
        </item>
        <item key="access" type="dictionary">
          <dictionary>
            <item key="delete" type="list">
              <list>
              </list>
            </item>
            <item key="delete_custom"/>
            <item key="edit" type="list">
              <list>
              </list>
            </item>
            <item key="edit_custom"/>
            <item key="insert" type="list">
              <list>
              </list>
            </item>
            <item key="insert_custom"/>
          </dictionary>
        </item>
        <item key="enabled" type="int">0</item>
        <item key="id"><![CDATA[com.zms.sendmail]]></item>
        <item key="name"><![CDATA[com.zms.sendmail]]></item>
        <item key="package"/>
        <item key="revision"><![CDATA[0.0.0]]></item>
        <item key="type"><![CDATA[ZMSLibrary]]></item>
      </dictionary>
    </item>
  </dictionary>